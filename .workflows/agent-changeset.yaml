agents:
  changeset_analyzer:
    model: deepseek:deepseek-chat
    system_prompt: |
      You are a changeset analyzer and release manager for a monorepo using changesets.

      Your task is to:
      1. Analyze PR changes to determine which packages are affected
      2. Determine the appropriate version bump type (patch/minor/major) based on:
         - Commit messages (conventional commits: fix/feat/BREAKING CHANGE)
         - PR description and title
         - Code changes (API changes, breaking changes)
      3. Generate changeset file
      4. Run `bun run version` to update package versions and CHANGELOGs
      5. Create a Version PR with all changes ready for review and merge

      Guidelines:
      - patch: bug fixes, documentation, internal refactors
      - minor: new features, new exports (backward compatible)
      - major: breaking changes, removed APIs, changed behavior
      - Look for keywords: "BREAKING", "breaking change", "feat:", "fix:", etc.
      - Multiple packages can be affected by one PR
      - If no changeset is needed (e.g., docs only, config only), say so explicitly

      Output format:
      1. Analysis summary (which packages, what type of change)
      2. Bash commands to create changeset, update versions, and create PR

      Important:
      - Only generate changeset if code changes affect published packages
      - Skip if changes are only in .github/, docs/, or config files
      - Use the standard changeset format
      - After creating changeset, run `bun run version` to consume it and update versions
      - Create a PR with version updates ready for review
      - When this PR is merged, packages will be published automatically

context:
  provider: memory

setup:
  # Get repository default branch
  - shell: |
      gh repo view "$GITHUB_REPOSITORY" --json defaultBranchRef --jq '.defaultBranchRef.name'
    as: default_branch

  # Get the merged PR number (passed from GitHub Actions)
  - shell: |
      if [ -z "$PR_NUMBER" ]; then
        echo "Error: PR_NUMBER environment variable is required"
        exit 1
      fi
      echo "$PR_NUMBER"
    as: pr_number

  # Get PR information
  - shell: |
      gh pr view "${{ pr_number }}" --repo "$GITHUB_REPOSITORY" \
        --json title,body,author,labels,commits \
        --jq '{
          title: .title,
          body: .body,
          author: .author.login,
          labels: [.labels[].name],
          commits: [.commits[] | {message: .messageHeadline, body: .messageBody}]
        }'
    as: pr_info

  # Get changed files
  - shell: |
      gh pr view "${{ pr_number }}" --repo "$GITHUB_REPOSITORY" \
        --json files --jq '.files[].path'
    as: changed_files

  # Get PR diff (limited to prevent context overflow)
  - shell: |
      # Get diff and limit to 10000 characters to prevent model context overflow
      DIFF=$(gh pr diff "${{ pr_number }}" --repo "$GITHUB_REPOSITORY")
      DIFF_LENGTH=${#DIFF}

      if [ $DIFF_LENGTH -gt 10000 ]; then
        echo "âš ï¸ Diff is large ($DIFF_LENGTH chars), truncating to 10000 chars"
        echo "--- TRUNCATED DIFF (first 10000 chars) ---"
        echo "$DIFF" | head -c 10000
        echo ""
        echo "--- TRUNCATED (showing first 10000 of $DIFF_LENGTH chars) ---"
      else
        echo "$DIFF"
      fi
    as: pr_diff

  # Check for existing changesets in the merged PR
  - shell: |
      CHANGESETS=$(gh pr view "${{ pr_number }}" --repo "$GITHUB_REPOSITORY" \
        --json files --jq '.files[] | select(.path | startswith(".changeset/")) | .path')

      if [ -n "$CHANGESETS" ]; then
        echo "Existing changesets found:"
        echo "$CHANGESETS"
        echo "has_changeset=true"
      else
        echo "No changesets found in PR"
        echo "has_changeset=false"
      fi
    as: existing_changesets

  # List packages in monorepo (dynamically from workspaces)
  - shell: |
      if [ ! -f "package.json" ]; then
        echo "No package.json found"
        exit 0
      fi

      # Get workspace patterns from package.json
      WORKSPACE_PATTERNS=$(jq -r '.workspaces // [] | if type == "array" then .[] else .packages[]? end' package.json 2>/dev/null)

      if [ -z "$WORKSPACE_PATTERNS" ]; then
        echo "No workspaces configured"
        exit 0
      fi

      # Find and list all packages
      echo "$WORKSPACE_PATTERNS" | while read -r pattern; do
        # Expand glob pattern (e.g., "packages/*" -> packages/agent-worker, etc.)
        for pkg_json in ${pattern}/package.json; do
          if [ -f "$pkg_json" ]; then
            jq -r '.name // empty' "$pkg_json" 2>/dev/null
          fi
        done
      done | sort -u
    as: packages

kickoff: |
  @changeset_analyzer Analyze this merged PR to determine if a changeset should be generated.

  ## PR Information
  ```json
  ${{ pr_info }}
  ```

  ## Changed Files
  ```
  ${{ changed_files }}
  ```

  ## Existing Changesets
  ```
  ${{ existing_changesets }}
  ```

  ## Available Packages
  ```
  ${{ packages }}
  ```

  ## PR Diff
  ```diff
  ${{ pr_diff }}
  ```

  **Note**: If the diff is truncated, use the changed_files list and commit messages for analysis.

  ## Task

  1. **Check if changeset is needed**:
     - If `has_changeset=true` in existing changesets, STOP - changeset already exists
     - If changes only affect non-package code (.github/, docs/, root config), STOP - no changeset needed
     - Otherwise, proceed to generate changeset

  2. **Analyze the changes**:
     - Which packages are affected? (check changed_files against packages/)
     - What type of change? (patch/minor/major)
     - Evidence: commit messages, PR title/body, code diff

  3. **Generate changeset and update versions** (if needed):
     - Create a properly formatted changeset file
     - Run `bun run version` to consume changeset and update package.json/CHANGELOG.md
     - Create a PR with all version updates

  4. **Execute commands** (if changeset is needed):
     ```bash
     # Generate a unique changeset ID
     CHANGESET_ID="auto-$(date +%Y%m%d-%H%M%S)"

     # Create changeset file with proper format
     cat > .changeset/${CHANGESET_ID}.md << 'EOF'
     ---
     "package-name": patch|minor|major
     ---

     Brief description of the change (from PR title/commits)
     EOF

     # Create a new branch for version PR
     git checkout -b release/auto-${{ pr_number }}

     # Commit the changeset
     git add .changeset/${CHANGESET_ID}.md
     git commit -m "chore: add changeset for PR #${{ pr_number }}"

     # Run version to update package.json and CHANGELOG.md
     bun run version

     # Commit version updates (changeset file will be deleted by `bun run version`)
     git add -A
     git commit -m "chore: version packages"

     # Push the branch
     git push -u origin release/auto-${{ pr_number }}

     # Create PR with analysis details
     gh pr create \
       --title "chore: release packages (from PR #${{ pr_number }})" \
       --body "ðŸ¤– Auto-generated version bump for merged PR #${{ pr_number }}

     ## Analysis
     - **Affected packages**: [list the packages]
     - **Version bump**: [patch/minor/major]
     - **Reason**: [brief explanation based on commits/PR]

     ## Changes
     - Updated package.json versions
     - Updated CHANGELOG.md files
     - Changeset has been consumed

     ## Next Steps
     Merge this PR to publish packages to npm.

     ---
     *Generated by changeset-agent*
     *Source: #${{ pr_number }}*" \
       --base ${{ default_branch }}
     ```

  **Important**:
  - Only proceed if changeset is actually needed (no existing changeset + package code changed)
  - Use correct package names from the packages list
  - Provide detailed reasoning in your analysis
  - Include the PR title/description context in the changeset
  - Execute all bash commands using the Bash tool
  - `bun run version` will consume the changeset and delete it
  - The created PR will be ready to merge for publishing
  - If any command fails, report the error clearly and stop
