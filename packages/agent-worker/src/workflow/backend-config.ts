/**
 * MCP Configuration Generator
 * Generates MCP configuration files for different backends
 */

import {
  writeFileSync,
  readFileSync,
  existsSync,
  mkdirSync,
  renameSync,
  unlinkSync,
} from "node:fs";
import { join, resolve } from "node:path";
import type { BackendType } from "../backends/types.ts";

/**
 * Resolve the command and prefix args to invoke agent-worker CLI.
 * Uses the current process's runtime + loader flags + script path
 * so the subprocess runs in the same environment as the parent.
 */
function resolveAgentWorkerCLI(): { command: string; prefixArgs: string[] } {
  const scriptPath = process.argv[1];
  if (scriptPath) {
    return {
      command: process.execPath,
      prefixArgs: [...process.execArgv, resolve(scriptPath)],
    };
  }
  return { command: "agent-worker", prefixArgs: [] };
}

/**
 * MCP server definition for config files
 */
export interface MCPServerConfig {
  /** Path to the Unix socket */
  socketPath: string;
  /** Agent identity for the MCP connection */
  agentId: string;
  /** Optional server name */
  name?: string;
}

/**
 * Generate MCP config for a specific backend
 */
export function generateMCPConfig(
  backend: BackendType,
  config: MCPServerConfig,
  workingDir: string,
): MCPConfigResult {
  switch (backend) {
    case "claude":
      return generateClaudeMCPConfig(config, workingDir);
    case "codex":
      return generateCodexMCPConfig(config, workingDir);
    case "cursor":
      return generateCursorMCPConfig(config, workingDir);
    case "sdk":
      return generateSDKMCPConfig(config);
    default:
      throw new Error(`Unsupported backend for MCP config: ${backend}`);
  }
}

/**
 * Result of MCP config generation
 */
export interface MCPConfigResult {
  /** Config type */
  type: "file" | "flags" | "env";
  /** Path to config file (for file type) */
  configPath?: string;
  /** CLI flags to pass (for flags type) */
  flags?: string[];
  /** Environment variables (for env type) */
  env?: Record<string, string>;
  /** Backup path if file was modified */
  backupPath?: string;
  /** Restore function to revert changes */
  restore?: () => void;
}

/**
 * Claude CLI: Generate temp config file and return --mcp-config flag
 *
 * Config format (JSON):
 * {
 *   "mcpServers": {
 *     "context": {
 *       "command": "nc",
 *       "args": ["-U", "/path/to/socket"]
 *     }
 *   }
 * }
 */
function generateClaudeMCPConfig(config: MCPServerConfig, workingDir: string): MCPConfigResult {
  const configDir = join(workingDir, ".agent-worker");
  if (!existsSync(configDir)) {
    mkdirSync(configDir, { recursive: true });
  }

  const configPath = join(configDir, `mcp-${config.agentId}.json`);

  // Generate MCP config that connects to the Unix socket
  const { command, prefixArgs } = resolveAgentWorkerCLI();
  const mcpConfig = {
    mcpServers: {
      context: {
        command,
        args: [
          ...prefixArgs,
          "context",
          "mcp-stdio",
          "--socket",
          config.socketPath,
          "--agent",
          config.agentId,
        ],
      },
    },
  };

  writeFileSync(configPath, JSON.stringify(mcpConfig, null, 2));

  return {
    type: "flags",
    configPath,
    flags: ["--mcp-config", configPath],
  };
}

/**
 * Codex CLI: Manage .codex/config.toml
 *
 * Config format (TOML):
 * [mcp_servers.context]
 * command = "agent-worker"
 * args = ["context", "mcp-stdio", "--socket", "/path/to/socket", "--agent", "agentId"]
 */
function generateCodexMCPConfig(config: MCPServerConfig, workingDir: string): MCPConfigResult {
  const codexDir = join(workingDir, ".codex");
  const configPath = join(codexDir, "config.toml");
  let backupPath: string | undefined;
  let originalContent: string | undefined;

  // Ensure directory exists
  mkdirSync(codexDir, { recursive: true });

  // Read existing config (if any) and create backup atomically
  try {
    originalContent = readFileSync(configPath, "utf-8");
    backupPath = `${configPath}.bak`;
    renameSync(configPath, backupPath);
  } catch {
    // No existing config or read failed — proceed without backup
  }

  // Generate TOML config
  const { command: codexCmd, prefixArgs: codexPrefix } = resolveAgentWorkerCLI();
  const socketEscaped = config.socketPath.replace(/\\/g, "\\\\");
  const allArgs = [
    ...codexPrefix,
    "context",
    "mcp-stdio",
    "--socket",
    socketEscaped,
    "--agent",
    config.agentId,
  ];
  const argsToml = allArgs
    .map((a) => `"${a.replace(/\\/g, "\\\\").replace(/"/g, '\\"')}"`)
    .join(", ");
  const tomlContent = `# Auto-generated by agent-worker
[mcp_servers.context]
command = "${codexCmd.replace(/\\/g, "\\\\").replace(/"/g, '\\"')}"
args = [${argsToml}]
`;

  // If there was existing content, append our config
  if (originalContent) {
    // Check if context server already exists
    if (!originalContent.includes("[mcp_servers.context]")) {
      writeFileSync(configPath, originalContent + "\n" + tomlContent);
    } else {
      // Replace existing context config
      const newContent = originalContent.replace(
        /\[mcp_servers\.context\][\s\S]*?(?=\[|$)/,
        tomlContent,
      );
      writeFileSync(configPath, newContent);
    }
  } else {
    writeFileSync(configPath, tomlContent);
  }

  return {
    type: "file",
    configPath,
    backupPath,
    restore: () => {
      if (backupPath && existsSync(backupPath)) {
        renameSync(backupPath, configPath);
      } else if (existsSync(configPath)) {
        unlinkSync(configPath);
      }
    },
  };
}

/**
 * Cursor Agent: Manage .cursor/mcp.json
 *
 * Config format (JSON):
 * {
 *   "mcpServers": {
 *     "context": {
 *       "command": "agent-worker",
 *       "args": ["context", "mcp-stdio", "--socket", "/path/to/socket", "--agent", "agentId"]
 *     }
 *   }
 * }
 */
function generateCursorMCPConfig(config: MCPServerConfig, workingDir: string): MCPConfigResult {
  const cursorDir = join(workingDir, ".cursor");
  const configPath = join(cursorDir, "mcp.json");
  let backupPath: string | undefined;
  let originalContent: Record<string, unknown> = {};

  // Ensure directory exists
  mkdirSync(cursorDir, { recursive: true });

  // Read existing config (if any) and create backup atomically
  try {
    originalContent = JSON.parse(readFileSync(configPath, "utf-8"));
    backupPath = `${configPath}.bak`;
    renameSync(configPath, backupPath);
  } catch {
    // No existing config or read/parse failed — proceed with empty config
  }

  // Generate JSON config
  const { command: cursorCmd, prefixArgs: cursorPrefix } = resolveAgentWorkerCLI();
  const mcpConfig = {
    ...originalContent,
    mcpServers: {
      ...(originalContent.mcpServers as Record<string, unknown>),
      context: {
        command: cursorCmd,
        args: [
          ...cursorPrefix,
          "context",
          "mcp-stdio",
          "--socket",
          config.socketPath,
          "--agent",
          config.agentId,
        ],
      },
    },
  };

  writeFileSync(configPath, JSON.stringify(mcpConfig, null, 2));

  return {
    type: "file",
    configPath,
    backupPath,
    restore: () => {
      if (backupPath && existsSync(backupPath)) {
        renameSync(backupPath, configPath);
      } else if (existsSync(configPath)) {
        unlinkSync(configPath);
      }
    },
  };
}

/**
 * SDK Backend: Return environment variable for MCP socket
 * The SDK backend reads MCP_SOCKET_PATH and connects directly
 */
function generateSDKMCPConfig(config: MCPServerConfig): MCPConfigResult {
  return {
    type: "env",
    env: {
      MCP_SOCKET_PATH: config.socketPath,
      MCP_AGENT_ID: config.agentId,
    },
  };
}

/**
 * Clean up all generated MCP configs
 */
export function cleanupMCPConfigs(results: MCPConfigResult[]): void {
  for (const result of results) {
    if (result.restore) {
      result.restore();
    }
  }
}
