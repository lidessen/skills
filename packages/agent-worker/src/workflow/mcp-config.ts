/**
 * MCP Configuration Generator
 * Generates MCP configuration files for different backends
 */

import { writeFileSync, readFileSync, existsSync, mkdirSync, renameSync } from 'node:fs'
import { dirname, join, resolve } from 'node:path'
import type { BackendType } from '../backends/types.ts'

/**
 * MCP server definition for config files
 */
export interface MCPServerConfig {
  /** Path to the Unix socket */
  socketPath: string
  /** Agent identity for the MCP connection */
  agentId: string
  /** Optional server name */
  name?: string
}

/**
 * Generate MCP config for a specific backend
 */
export function generateMCPConfig(
  backend: BackendType,
  config: MCPServerConfig,
  workingDir: string
): MCPConfigResult {
  switch (backend) {
    case 'claude':
      return generateClaudeMCPConfig(config, workingDir)
    case 'codex':
      return generateCodexMCPConfig(config, workingDir)
    case 'cursor':
      return generateCursorMCPConfig(config, workingDir)
    case 'sdk':
      return generateSDKMCPConfig(config)
    default:
      throw new Error(`Unsupported backend for MCP config: ${backend}`)
  }
}

/**
 * Result of MCP config generation
 */
export interface MCPConfigResult {
  /** Config type */
  type: 'file' | 'flags' | 'env'
  /** Path to config file (for file type) */
  configPath?: string
  /** CLI flags to pass (for flags type) */
  flags?: string[]
  /** Environment variables (for env type) */
  env?: Record<string, string>
  /** Backup path if file was modified */
  backupPath?: string
  /** Restore function to revert changes */
  restore?: () => void
}

/**
 * Claude CLI: Generate temp config file and return --mcp-config flag
 *
 * Config format (JSON):
 * {
 *   "mcpServers": {
 *     "context": {
 *       "command": "nc",
 *       "args": ["-U", "/path/to/socket"]
 *     }
 *   }
 * }
 */
function generateClaudeMCPConfig(config: MCPServerConfig, workingDir: string): MCPConfigResult {
  const configDir = join(workingDir, '.agent-worker')
  if (!existsSync(configDir)) {
    mkdirSync(configDir, { recursive: true })
  }

  const configPath = join(configDir, `mcp-${config.agentId}.json`)

  // Generate MCP config that connects to the Unix socket
  // Using agent-worker CLI wrapper as the MCP server command
  const mcpConfig = {
    mcpServers: {
      context: {
        command: 'agent-worker',
        args: ['context', 'mcp-stdio', '--socket', config.socketPath, '--agent', config.agentId],
      },
    },
  }

  writeFileSync(configPath, JSON.stringify(mcpConfig, null, 2))

  return {
    type: 'flags',
    configPath,
    flags: ['--mcp-config', configPath],
  }
}

/**
 * Codex CLI: Manage .codex/config.toml
 *
 * Config format (TOML):
 * [mcp_servers.context]
 * command = "agent-worker"
 * args = ["context", "mcp-stdio", "--socket", "/path/to/socket", "--agent", "agentId"]
 */
function generateCodexMCPConfig(config: MCPServerConfig, workingDir: string): MCPConfigResult {
  const codexDir = join(workingDir, '.codex')
  const configPath = join(codexDir, 'config.toml')
  let backupPath: string | undefined
  let originalContent: string | undefined

  // Backup existing config
  if (existsSync(configPath)) {
    backupPath = `${configPath}.bak`
    originalContent = readFileSync(configPath, 'utf-8')
    renameSync(configPath, backupPath)
  } else {
    mkdirSync(codexDir, { recursive: true })
  }

  // Generate TOML config
  const socketEscaped = config.socketPath.replace(/\\/g, '\\\\')
  const tomlContent = `# Auto-generated by agent-worker
[mcp_servers.context]
command = "agent-worker"
args = ["context", "mcp-stdio", "--socket", "${socketEscaped}", "--agent", "${config.agentId}"]
`

  // If there was existing content, append our config
  if (originalContent) {
    // Check if context server already exists
    if (!originalContent.includes('[mcp_servers.context]')) {
      writeFileSync(configPath, originalContent + '\n' + tomlContent)
    } else {
      // Replace existing context config
      const newContent = originalContent.replace(
        /\[mcp_servers\.context\][\s\S]*?(?=\[|$)/,
        tomlContent
      )
      writeFileSync(configPath, newContent)
    }
  } else {
    writeFileSync(configPath, tomlContent)
  }

  return {
    type: 'file',
    configPath,
    backupPath,
    restore: () => {
      if (backupPath && existsSync(backupPath)) {
        renameSync(backupPath, configPath)
      } else if (existsSync(configPath)) {
        // Remove generated config
        const { unlinkSync } = require('node:fs')
        unlinkSync(configPath)
      }
    },
  }
}

/**
 * Cursor Agent: Manage .cursor/mcp.json
 *
 * Config format (JSON):
 * {
 *   "mcpServers": {
 *     "context": {
 *       "command": "agent-worker",
 *       "args": ["context", "mcp-stdio", "--socket", "/path/to/socket", "--agent", "agentId"]
 *     }
 *   }
 * }
 */
function generateCursorMCPConfig(config: MCPServerConfig, workingDir: string): MCPConfigResult {
  const cursorDir = join(workingDir, '.cursor')
  const configPath = join(cursorDir, 'mcp.json')
  let backupPath: string | undefined
  let originalContent: Record<string, unknown> = {}

  // Backup existing config
  if (existsSync(configPath)) {
    backupPath = `${configPath}.bak`
    originalContent = JSON.parse(readFileSync(configPath, 'utf-8'))
    renameSync(configPath, backupPath)
  } else {
    mkdirSync(cursorDir, { recursive: true })
  }

  // Generate JSON config
  const mcpConfig = {
    ...originalContent,
    mcpServers: {
      ...(originalContent.mcpServers as Record<string, unknown> || {}),
      context: {
        command: 'agent-worker',
        args: ['context', 'mcp-stdio', '--socket', config.socketPath, '--agent', config.agentId],
      },
    },
  }

  writeFileSync(configPath, JSON.stringify(mcpConfig, null, 2))

  return {
    type: 'file',
    configPath,
    backupPath,
    restore: () => {
      if (backupPath && existsSync(backupPath)) {
        renameSync(backupPath, configPath)
      } else if (existsSync(configPath)) {
        const { unlinkSync } = require('node:fs')
        unlinkSync(configPath)
      }
    },
  }
}

/**
 * SDK Backend: Return environment variable for MCP socket
 * The SDK backend reads MCP_SOCKET_PATH and connects directly
 */
function generateSDKMCPConfig(config: MCPServerConfig): MCPConfigResult {
  return {
    type: 'env',
    env: {
      MCP_SOCKET_PATH: config.socketPath,
      MCP_AGENT_ID: config.agentId,
    },
  }
}

/**
 * Clean up all generated MCP configs
 */
export function cleanupMCPConfigs(results: MCPConfigResult[]): void {
  for (const result of results) {
    if (result.restore) {
      result.restore()
    }
  }
}
